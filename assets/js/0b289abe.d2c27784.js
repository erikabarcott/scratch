"use strict";(self.webpackChunkcodiac=self.webpackChunkcodiac||[]).push([[8674],{3892:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var s=n(4848),i=n(8453);const o={},a="Custom Validation",r={id:"api-base/basics/custom-validation",title:"Custom Validation",description:"Adding custom validation involves two steps:",source:"@site/docs/api-base/basics/custom-validation.md",sourceDirName:"api-base/basics",slug:"/api-base/basics/custom-validation",permalink:"/scratch/api-base/basics/custom-validation",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-base/basics/custom-validation.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Custom Filter Types",permalink:"/scratch/api-base/basics/custom-filter-defs"},next:{title:"Patch and Update",permalink:"/scratch/api-base/basics/patch-and-update"}},l={},c=[{value:"<a></a>Step 1: Create a <code>ValidationDef</code> for your entity.",id:"step-1-create-a-validationdef-for-your-entity",level:2},{value:"Property-Scoped Constraints",id:"property-scoped-constraints",level:3},{value:"Entity-Scoped Constraints",id:"entity-scoped-constraints",level:3},{value:"Globally Scoped Constraints",id:"globally-scoped-constraints",level:3},{value:"Built-in constraints",id:"built-in-constraints",level:3},{value:"Validation context",id:"validation-context",level:3},{value:"<a></a>Step 2: Register your validationDef with the API",id:"step-2-register-your-validationdef-with-the-api",level:2}];function d(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"custom-validation",children:"Custom Validation"}),"\n",(0,s.jsx)(t.p,{children:"Adding custom validation involves two steps:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:["Step 1: ",(0,s.jsxs)(t.a,{href:"#step1",children:["Create a ",(0,s.jsx)(t.code,{children:"ValidationDef"})," for your entity."]})]}),"\n",(0,s.jsxs)(t.li,{children:["Step 2: ",(0,s.jsx)(t.a,{href:"#step2",children:"Register your validationDef with the API"})]}),"\n"]}),"\n",(0,s.jsxs)(t.h2,{id:"step-1-create-a-validationdef-for-your-entity",children:[(0,s.jsx)("a",{name:"step1"}),"Step 1: Create a ",(0,s.jsx)(t.code,{children:"ValidationDef"})," for your entity."]}),"\n",(0,s.jsx)(t.p,{children:"You will need to define an injectable class that will perform the actual validation against your entity type."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:"@injectable()\nexport class shoeValidator extends ValidatorDef<shoe>\n{\n    constructor() {\n        super(shoe);\n    }\n}\n"})}),"\n",(0,s.jsx)(t.p,{children:"Now let's add some constraints for this validator to enforce."}),"\n",(0,s.jsx)(t.h3,{id:"property-scoped-constraints",children:"Property-Scoped Constraints"}),"\n",(0,s.jsxs)(t.p,{children:["We're going to enforce that the property ",(0,s.jsx)(t.code,{children:"shoe.size"})," must be greater than 1."]}),"\n",(0,s.jsxs)(t.p,{children:["There's fluent methods for this on the ",(0,s.jsx)(t.code,{children:"ValidatorDef"}),".  In the constructor for your new validator class, use the ",(0,s.jsx)(t.code,{children:"enforces()"})," fluent method, and then the ",(0,s.jsx)(t.code,{children:"thatItMust()"})," fluent method to define the response message and logic of our new constraint:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:'this.enforces(s => s.size)\n    .thatItMust("be greater than 1", (val) => val > 1);\n'})}),"\n",(0,s.jsxs)(t.p,{children:["Notice that the lambda expression returns a boolean.  Returning ",(0,s.jsx)(t.code,{children:"false"}),' will evoke a validation failure, and the caller will be notified of the constraint requirements by way of your "that it must" description.  Returning ',(0,s.jsx)(t.code,{children:"true"})," will be interpreted as valid, and no error will be thrown."]}),"\n",(0,s.jsx)(t.p,{children:"This particular constraint is a simple one and needs no more information to perform its job than the value of the property it is enforcing.  But often, enforcing a constraint requires that the whole entity be in context so that we can compare one or more of its properties.  To use the entity itself in your constraint, simply add the entity as an argument to your lambda expression:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:'this.enforces(s => s.size)\n    .thatItMust("be set if the model is set", (val, ent) => (ent.model) ? val != null : true);\n'})}),"\n",(0,s.jsxs)(t.p,{children:["...and just for practice, lets add another property-scoped constraint limiting ",(0,s.jsx)(t.code,{children:"brand"})," to 35 characters:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:'this.enforces(s => s.size)\n    .thatItMust("be greater than 1", (val) => val > 1)\nthis.enforces(s => s.size)\n    .thatItMust("be set if the model is set", (val, ent) => (ent.model) ? val != null : true);\nthis.enforces(s => s.brand)\n    .thatItMust("Be 35 chars or less", (val,ent) => (!val || val.length<= 35));\n'})}),"\n",(0,s.jsx)(t.h3,{id:"entity-scoped-constraints",children:"Entity-Scoped Constraints"}),"\n",(0,s.jsxs)(t.p,{children:["Perhaps the nature of the constraint is not relevant to one specific property, but is more applicable to an overall state of the entity itself?  This is called an Entity-Scoped Constraint, and we can define it using the ",(0,s.jsx)(t.code,{children:"ensuresThatItMust()"})," fluent method."]}),"\n",(0,s.jsx)(t.p,{children:"For instance, lets say Reebok only offers specific size ranges for each gender, and we have to enforce Reebok female shoe sizes to run from 2 to 10 and male sizes from 6 to 14:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:'this.ensuresThatItMust("have a size compatible with its gender", s => {\n    if (s.brand == "Reebok")\n    {\n        if (s.gender == "F") {\n            return 2 <= s.size && s.size <= 10;\n        } else {\n            return 6 <= s.size && s.size <= 14;\n        }\n    }\n    else\n    {\n        return true;\n    }\n});\n'})}),"\n",(0,s.jsx)(t.p,{children:"The result of an entity-scoped constraint will not be bound to a single specific property, and will appear at the summary level in the validation response."}),"\n",(0,s.jsx)(t.h3,{id:"globally-scoped-constraints",children:"Globally Scoped Constraints"}),"\n",(0,s.jsx)(t.p,{children:"What if, in order to validate your entity, you had to look not just at your entity itself, but the other existing entities?"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"For example"}),": say we are trying to save a new shoe, and need to validate that the SKU we gave it (Stock Keeping Unit) is unique in the system.  That is, we want to run a lookup against the database to see if that sku already exists."]}),"\n",(0,s.jsxs)(t.p,{children:["Well first thing you'll need is an instance of a ",(0,s.jsx)(t.code,{children:"shoe"})," repo to perform this query.  However, the arguments to the validation logic contain only the entity itself and the validation context object; where do we get the repo?"]}),"\n",(0,s.jsx)(t.p,{children:"Constructor injection is the pattern you are looking for.  This is your validation class, so you get to define the constructor, and the constructor injection pattern is supported in full by this system."}),"\n",(0,s.jsx)(t.p,{children:"Thus, whatever you need to perform that validation, you can add as an injected constructor argument:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:"@injectable()\nexport class shoeValidator extends ValidatorDef<shoe>\n{\n    constructor(@inject(INTERFACES.IRepo) private repo: IRepo) {\n        super(shoe);\n    }\n}\n"})}),"\n",(0,s.jsxs)(t.p,{children:["Now you can call it out inside your constraint logic using ",(0,s.jsx)(t.code,{children:"this.repo"}),"."]}),"\n",(0,s.jsx)(t.p,{children:"Below we'll add a new constraint for the SKU, and use that repo instance to check for any duplicate SKUs."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:'this.enforces(s => s.sku)\n    .thatItMust("not already exist on another entity", (sku, entity) => {\n        let result = await this.repo.tryReadMany<shoe>(shoe, { "sku": sku });\n        return (result.count == 0);\n    });\n'})}),"\n",(0,s.jsxs)(t.p,{children:["So you can add whatever type of entity you like to your validation handlers.  The only requirement being that whatever you are injecting into your constructor, it must have been ",(0,s.jsx)(t.a,{href:"/scratch/api-base/basics/using-ioc",children:"registered with the API's IOC container"})," during the API bootstrapping."]}),"\n",(0,s.jsx)(t.p,{children:"Extensibility, folks!"}),"\n",(0,s.jsxs)(t.p,{children:["Now if you look closely at the constraint we just created for ",(0,s.jsx)(t.code,{children:"shoe.sku"}),", you might notice that we only want this constraint firing during a ",(0,s.jsx)(t.code,{children:"create"})," transaction, not in an ",(0,s.jsx)(t.code,{children:"update"})," transaction.  The validation context will tell us what operation is being performed, so let's use the ",(0,s.jsx)(t.code,{children:"IValidatorContext.operation"})," to specify that our new constraint on ",(0,s.jsx)(t.code,{children:"shoe.sku"})," only applies to ",(0,s.jsx)(t.code,{children:"create"})," transactions:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:'this.enforces(s => s.sku)\n    .thatItMust("not already exist on another entity", (sku, entity, context) => {\n        if (context.operation == "create")\n        {\n            let result = await this.repo.tryReadMany<shoe>(shoe, { "sku": sku });\n            return (result.count == 0);\n        } \n        return true;\n    });\n'})}),"\n",(0,s.jsx)(t.p,{children:"NOTE:  To keep the topic simple, we're not adding any error trapping or other bulletproofing to this constraint logic.  In the real woirld, you will likely be adding error checks to support a repo call that returned an exception."}),"\n",(0,s.jsx)(t.h3,{id:"built-in-constraints",children:"Built-in constraints"}),"\n",(0,s.jsx)(t.p,{children:"Call out a built-in constraint"}),"\n",(0,s.jsx)(t.h3,{id:"validation-context",children:"Validation context"}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes the operation being performed on the entity is relevant when determining which constraints apply.   The ",(0,s.jsx)(t.code,{children:"validationContext"})," object provides your lambda expression with that information."]}),"\n",(0,s.jsx)(t.p,{children:"it contains the operation and the validator options"}),"\n",(0,s.jsxs)(t.h2,{id:"step-2-register-your-validationdef-with-the-api",children:[(0,s.jsx)("a",{name:"step2"}),"Step 2: Register your validationDef with the API"]}),"\n",(0,s.jsx)(t.p,{children:"in the constructor of your api definition, declare each the custom validator for your entity:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-Typescript",children:"this.validateWith<shoe, shoeValidator>(shoe, shoeValidator)\n"})}),"\n",(0,s.jsx)(t.p,{children:"Once your validator is registered by entity type, your crud endpoints will invoke it as needed."})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);