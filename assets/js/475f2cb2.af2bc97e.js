"use strict";(self.webpackChunkcodiac=self.webpackChunkcodiac||[]).push([[560],{3842:(e,r,s)=>{s.r(r),s.d(r,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>h});var n=s(4848),t=s(8453);const o={},i="StringFilter Operators",a={id:"api-base/basics/StringFilter",title:"StringFilter Operators",description:"The StringFilter type provides some convenient search syntaxes, and the best part is that they're built in, so you wont have to write any custom code to support them.",source:"@site/docs/api-base/basics/StringFilter.md",sourceDirName:"api-base/basics",slug:"/api-base/basics/StringFilter",permalink:"/scratch/api-base/basics/StringFilter",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/api-base/basics/StringFilter.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"HATEOAS",permalink:"/scratch/api-base/basics/HATEOAS"},next:{title:"Adding a Custom Endpoint",permalink:"/scratch/api-base/basics/custom-endpoints"}},c={},h=[{value:"<a></a> The <code>StartsWith</code> Operator",id:"-the-startswith-operator",level:2},{value:"<a></a> The <code>EndsWith</code> Operator",id:"-the-endswith-operator",level:2},{value:"<a></a> The <code>Contains</code> Operator",id:"-the-contains-operator",level:2},{value:"<a></a> The <code>In</code> Operator",id:"-the-in-operator",level:2},{value:"<a></a> The <code>Pattern</code> Operator",id:"-the-pattern-operator",level:2},{value:"<a></a> The <code>Equals</code> Operator",id:"-the-equals-operator",level:2},{value:"<a></a> The <code>Not</code> Operator",id:"-the-not-operator",level:2}];function l(e){const r={a:"a",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(r.h1,{id:"stringfilter-operators",children:"StringFilter Operators"}),"\n",(0,n.jsx)(r.p,{children:"The StringFilter type provides some convenient search syntaxes, and the best part is that they're built in, so you wont have to write any custom code to support them."}),"\n",(0,n.jsxs)(r.p,{children:["Just prefix your value with an operator and an underscore ",(0,n.jsx)(r.code,{children:"'_'"})]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$sw_ree\n"})}),"\n",(0,n.jsxs)(r.p,{children:["This will return all shoes with brand names starting with the letters ",(0,n.jsx)(r.code,{children:'"ree"'})," (like Reebok).    ",(0,n.jsxs)(r.em,{children:["All StringFilter searches are ",(0,n.jsx)(r.em,{children:(0,n.jsx)(r.strong,{children:"case-INsensitive"})}),"."]})]}),"\n",(0,n.jsx)(r.p,{children:"You can invoke these behaviors by applying the following operators to your value"}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"#StartsWith",children:"StartsWith"}),": ",(0,n.jsx)(r.code,{children:"$sw_"})," or ",(0,n.jsx)(r.code,{children:"startswith_"})]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"#EndsWith",children:"EndsWith"}),": ",(0,n.jsx)(r.code,{children:"$ew_"})," or ",(0,n.jsx)(r.code,{children:"endswith_"})]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"#Contains",children:"Contains"}),": ",(0,n.jsx)(r.code,{children:"$cn_"})," or ",(0,n.jsx)(r.code,{children:"contains_"})]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"#In",children:"In List"}),": ",(0,n.jsx)(r.code,{children:"$in_"})," or ",(0,n.jsx)(r.code,{children:"in_"})]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"#Pattern",children:"RegEx Pattern"}),": ",(0,n.jsx)(r.code,{children:"$pn_"})," or ",(0,n.jsx)(r.code,{children:"pattern_"})]}),"\n",(0,n.jsxs)(r.li,{children:[(0,n.jsx)(r.a,{href:"#Equals",children:"Equals"}),": ",(0,n.jsx)(r.code,{children:"$eq_"})," or ",(0,n.jsx)(r.code,{children:"equals_"})]}),"\n"]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.em,{children:(0,n.jsx)(r.strong,{children:"AND"})})}),"\n",(0,n.jsxs)(r.p,{children:["All of these operators can also be inversed with the ",(0,n.jsxs)(r.a,{href:"#Not",children:[(0,n.jsx)(r.code,{children:"NOT"})," operator: ",(0,n.jsx)(r.code,{children:"!"})]})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-startswith-operator",children:[(0,n.jsx)("a",{name:"StartsWith"})," The ",(0,n.jsx)(r.code,{children:"StartsWith"})," Operator"]}),"\n",(0,n.jsxs)(r.p,{children:["To search on string properties that ",(0,n.jsx)(r.strong,{children:"start with"})," a given value ",(0,n.jsx)(r.em,{children:'(eg: "N" to find "Nike" and "New Balance")'}),", prefix your value with ",(0,n.jsx)(r.code,{children:"$sw_"})," or ",(0,n.jsx)(r.code,{children:"startswith_"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$sw_N\nor\nshoes?brand=startswith_N\n"})}),"\n",(0,n.jsxs)(r.p,{children:["NOTE:  ",(0,n.jsxs)(r.em,{children:["All StringFilter prefixes such as these are NOT case-sensitive, so ",(0,n.jsx)(r.code,{children:"?StartsWiTH_N"})," will work just as well as ",(0,n.jsx)(r.code,{children:"?startswith_N"})," or ",(0,n.jsx)(r.code,{children:"?$SW_N"}),"."]})]}),"\n",(0,n.jsxs)(r.p,{children:["You can also invoke the ",(0,n.jsx)(r.a,{href:"#Not",children:"Not operator"}),": ",(0,n.jsx)(r.code,{children:"!$sw_"})," or ",(0,n.jsx)(r.code,{children:"!startsWith_"})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-endswith-operator",children:[(0,n.jsx)("a",{name:"EndsWith"})," The ",(0,n.jsx)(r.code,{children:"EndsWith"})," Operator"]}),"\n",(0,n.jsxs)(r.p,{children:["To search on string properties that ",(0,n.jsx)(r.strong,{children:"end with"})," a given value ",(0,n.jsx)(r.em,{children:'(eg: "e" to find "Nike" and "New Balance")'}),", prefix your value with ",(0,n.jsx)(r.code,{children:"$ew_"})," or ",(0,n.jsx)(r.code,{children:"endsswith_"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$ew_e\nor\nshoes?brand=endswith_e\n"})}),"\n",(0,n.jsxs)(r.p,{children:["You can also invoke the ",(0,n.jsx)(r.a,{href:"#Not",children:"Not operator"}),": ",(0,n.jsx)(r.code,{children:"!$ew_"})," or ",(0,n.jsx)(r.code,{children:"!endsWith_"})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-contains-operator",children:[(0,n.jsx)("a",{name:"Contains"})," The ",(0,n.jsx)(r.code,{children:"Contains"})," Operator"]}),"\n",(0,n.jsxs)(r.p,{children:["To find strings that contain a given value ",(0,n.jsx)(r.em,{children:'(eg: "ok" to find "Brooks" and "Reebok")'})," prefix your value with ",(0,n.jsx)(r.code,{children:"$cn_"})," or ",(0,n.jsx)(r.code,{children:"contains_"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$cn_ok\nor\nshoes?brand=contains_ok\n"})}),"\n",(0,n.jsxs)(r.p,{children:["You can also invoke the ",(0,n.jsx)(r.a,{href:"#Not",children:"Not operator"}),": ",(0,n.jsx)(r.code,{children:"!$cn_"})," or ",(0,n.jsx)(r.code,{children:"!contains_"})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-in-operator",children:[(0,n.jsx)("a",{name:"In"})," The ",(0,n.jsx)(r.code,{children:"In"})," Operator"]}),"\n",(0,n.jsxs)(r.p,{children:["Whereas a simple equals operator limits results to those matching a single value, the ",(0,n.jsx)(r.code,{children:"$in"})," operator allows you to limit results to those matching one of several values.",(0,n.jsx)(r.br,{}),"\n","That is, if you want not only Nike shoes but Brooks and Asics too, pass all three brands as your value (separated by commas) and prefix the whole thing with ",(0,n.jsx)(r.code,{children:"$in_"})," or ",(0,n.jsx)(r.code,{children:"in_"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$in_Nike,Brooks,Asics\nor\nshoes?brand=in_Nike,Brooks,Asics\n"})}),"\n",(0,n.jsx)(r.p,{children:'This syntax employs "OR" logic:  where brand equals "Nike" OR "Brooks" OR "Asics"'}),"\n",(0,n.jsxs)(r.p,{children:["You can also invoke the ",(0,n.jsx)(r.a,{href:"#Not",children:"Not operator"}),": ",(0,n.jsx)(r.code,{children:"!$in_"})," or ",(0,n.jsx)(r.code,{children:"!in_"})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-pattern-operator",children:[(0,n.jsx)("a",{name:"Pattern"})," The ",(0,n.jsx)(r.code,{children:"Pattern"})," Operator"]}),"\n",(0,n.jsxs)(r.p,{children:["RegExes anyone? (aka: Regular Expressions, aka: string patterns)  If you want to search on values that conform to a more complex set of rules, you can pass in a ",(0,n.jsx)(r.a,{href:"https://regexr.com/",children:"regular expression"})," as your value and prefix it with the ",(0,n.jsx)(r.code,{children:"pattern"})," operator or ",(0,n.jsx)(r.code,{children:"$pn"}),":"]}),"\n",(0,n.jsx)(r.p,{children:"let's say we want shoes whose brands have two words in their name:"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-RegExp",children:"/\\w+\\s\\w+/   \n"})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"Url-encoded:  %2F%5Cw%2B%5Cs%5Cw%2B%2Fi\n"})}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsxs)(r.em,{children:["NOTE: Obviously special characters could be trouble here, so always be sure to ",(0,n.jsx)(r.a,{href:"https://meyerweb.com/eric/tools/dencoder/",children:"Url-encode"})," your values before adding them to the querystring"]})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$pn_%2F%5Cw%2B%5Cs%5Cw%2B%2Fi\nor\nshoes?brand=pattern_%2F%5Cw%2B%5Cs%5Cw%2B%2Fi\n"})}),"\n",(0,n.jsxs)(r.p,{children:["NOTE:  ",(0,n.jsxs)(r.em,{children:["Yes, we url-encoded before prefixing instead of url-encoding the whole value, but it's legal to do so because the prefixes are made up of legal URL characters that do not need encoding (via ",(0,n.jsx)(r.a,{href:"https://www.ietf.org/rfc/rfc3986.txt",children:"RFC3986"})," and ",(0,n.jsx)(r.a,{href:"https://www.ietf.org/rfc/rfc1738.txt",children:"RFC1738"}),")."]})]}),"\n",(0,n.jsxs)(r.p,{children:["You can also invoke the ",(0,n.jsx)(r.a,{href:"#Not",children:"Not operator"}),":  ",(0,n.jsx)(r.code,{children:"!$pn_"})," or ",(0,n.jsx)(r.code,{children:"!pattern_"})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-equals-operator",children:[(0,n.jsx)("a",{name:"Equals"})," The ",(0,n.jsx)(r.code,{children:"Equals"})," Operator"]}),"\n",(0,n.jsx)(r.p,{children:(0,n.jsx)(r.em,{children:"You may never use this because it's already the default behavior of a search string that is not prefixed with an operator."})}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{children:"shoes?brand=nike\n"})}),"\n",(0,n.jsxs)(r.p,{children:["But if you felt the need to explicitly call it out, you can instead prefix your value with ",(0,n.jsx)(r.code,{children:"$eq_"})," or ",(0,n.jsx)(r.code,{children:"equals_"}),":"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=$eq_nike\nor\nshoes?brand=equals_nike\n"})}),"\n",(0,n.jsxs)(r.p,{children:["You can also invoke the ",(0,n.jsx)(r.a,{href:"#Not",children:"Not operator"}),":  ",(0,n.jsx)(r.code,{children:"!$eq_"})," or ",(0,n.jsx)(r.code,{children:"!equals_"})]}),"\n",(0,n.jsxs)(r.h2,{id:"-the-not-operator",children:[(0,n.jsx)("a",{name:"Not"})," The ",(0,n.jsx)(r.code,{children:"Not"})," Operator"]}),"\n",(0,n.jsxs)(r.p,{children:["The Not operator (",(0,n.jsx)(r.code,{children:"!"}),") exists as an optional prefix that you can apply to the other operators, which inverts their logic to include anything NOT MATCHING their logic."]}),"\n",(0,n.jsxs)(r.p,{children:['For example, If you want all shoes other than "Nike", you can prefix the ',(0,n.jsx)(r.code,{children:"Equals"})," operator with the ",(0,n.jsx)(r.code,{children:"Not"})," operator:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-url",children:"shoes?brand=!$eq_nike\nor\nshoes?brand=!equals_Nike\n"})}),"\n",(0,n.jsxs)(r.p,{children:["And in case you were wondering, there is NO NEED to url-encode the ",(0,n.jsx)(r.code,{children:"!"})," exclamation point.  The Internet Engineering Task Force (IETF) clearly defined it as a safe character in:"]}),"\n",(0,n.jsxs)(r.ul,{children:["\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://www.ietf.org/rfc/rfc3986.txt",children:"RFC3986: Uniform Resource Identifier (URI): Generic Syntax"})}),"\n",(0,n.jsx)(r.li,{children:(0,n.jsx)(r.a,{href:"https://www.ietf.org/rfc/rfc1738.txt",children:"RFC1738: Uniform Resource Locators (URL)"})}),"\n"]})]})}function d(e={}){const{wrapper:r}={...(0,t.R)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(l,{...e})}):l(e)}},8453:(e,r,s)=>{s.d(r,{R:()=>i,x:()=>a});var n=s(6540);const t={},o=n.createContext(t);function i(e){const r=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function a(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),n.createElement(o.Provider,{value:r},e.children)}}}]);